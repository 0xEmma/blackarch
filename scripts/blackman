#!/bin/bash
# Acts sort of like pacman.
# This script may called from any location but the script itself must
#  live in '$projectroot/scripts'.

usage() {
	cat >&2 <<-USAGE
	blackman [-h|--help] action
	USAGE
}

error() {
	echo >&2 "blackman: $@ (use -h for help)"
}

cd "$(dirname "$0")/.."

targets=()
action=none
print_only=false
no_deps=false

for arg ; do
	if [[ $arg == -* ]] ; then
		case $arg in
			-h|--help)
				usage
				exit
				;;
			-S) action=sync ;;
			-Sd) action=sync; no_deps=true ;;
			-Sp) action=sync; print_only=true ;;
			-Sdp|-Spd) action=sync ; print_only=true ; no_deps=true ;;
			-Ss) action=search ;;
			-Sg) action=groups ;;
			-Sgg) action=groupings ;;
			#-Sb) action=buildonly ;;
			-Si) action=info ;;
			-Sl) action=list ;;
			-Syu|-Su) action=upgrade ;;
			*)
				error "unsupported: $arg"
				exit 1
				;;
		esac
	else
		targets+=($arg)
	fi
done

if [[ $action == none ]] ; then
	error 'no action specified'
	exit 1
fi

# Recursively prints a package's BlackArch dependencies.
# Offical repo dependencies are not printed.
# Output is as such:
#  <depth> <package>
# The output is not guaranteed to be sorted by depth
# TODO: clean this up a bit.
n=0
get_blackarch_deps() {
	local pack=$1
	(( n++ ))

	echo $1 >> ~/alog
	echo N $n >> ~/alog

	# Don't do anything if maximum depth reached or no package passed.
	if [[ $n == 10 || $# == 0 ]] ; then
		return
	fi

	(
	if source packages/$pack/PKGBUILD &> /dev/null ; then
		# Don't print the first package.
		if [[ $n != 1 ]] ; then
			echo $n $pack
		fi
	else
		# Don't do anything if the package couldn't be sourced.
		return
	fi

	for dep in "${depends[@]}" ; do
		get_blackarch_deps "$(sed 's/\(>\|<\|=\).*//' <<< $dep)"
	done
	) | sort -k2 -u
}

do_sync() { (
	local pack=$1
	shift

	cd packages/$pack
	makepkg "$@" -fs
	# TODO: improve this sort.
	local file=$(find . -maxdepth 1 -name '*.pkg.tar.xz' | sort -n | head -n1)
	# xargs doesn't work here.
	sudo pacman "$@" -U "$file"
) }

is_installed() {
	pacman -Qi "$1" &> /dev/null
}

case $action in
	sync)
		# Check for targets.
		if [[ ${#targets[@]} == 0 ]] ; then
			error 'no targets specified'
			exit 3
		fi

		# Make sure the packages exist.
		for pack in "${targets[@]}" ; do
			if [[ ! -d packages/$pack ]] ; then
				error "could not find '$pack'"
				exit 2
			fi
		done

		for pack in "${targets[@]}" ; do (
			if ! $no_deps ; then
				while read dep <&3 ; do
					if ! is_installed $dep ; then
						if $print_only ; then
							echo $dep
						else
							do_sync $dep --asdeps 
						fi
					fi
				done 3< <(get_blackarch_deps "$pack" |
							sort -n |
							cut -d' ' -f2)
			fi

			if $print_only ; then
				echo "$pack"
			else
				if $no_deps ; then
					do_sync "$pack" -d -d
				else
					do_sync "$pack"
				fi
			fi
		) done
		;;
	search)
		# TODO: narrow down searches for each word instead
		for pattern in "${targets[@]:-^}" ; do
			for pack in packages/* ; do (
				source $pack/PKGBUILD
				if [[ "$pkgname $pkgdesc" =~ $pattern ]] ; then
					printf 'blackarch/%s %s-%s' "$pkgname" "$pkgver" "$pkgrel"
					[[ -n "${groups[*]}" ]] && printf ' (%s)' "${groups[*]}"
					is_installed "$pkgname" && printf ' [installed]'
					printf '\n'
					printf '    %s\n' "$pkgdesc"
				fi
			) ; done
		done
		;;
	groups)
		for pack in packages/* ; do (
			source $pack/PKGBUILD
			printf '%s\n' "${groups[@]}"
		) ; done | sort -u | sed '1d'
		;;
	groupings)
		for pack in packages/* ; do (
			source $pack/PKGBUILD
			if [[ -n "${groups[@]}" ]] ; then
				printf "%s $pkgname\n" "${groups[@]}"
			fi
		) ; done | LC_ALL=C sort
		# Many locales cause sort to ignore punctuation, including hyphens.
		;;
	info)
		for pack in "${targets[@]}" ; do (
			source packages/$pack/PKGBUILD

			size=$(du -hs packages/$pack/*.pkg.tar.xz | cut -d$'\t' -f1)

			[[ ${#md5sums[@]} != 0 ]] && validation+='MD5 Sum'
			[[ ${#sha256sums[@]} != 0 ]] && validation+='SHA256 Sum'
			[[ ${#sha1sums[@]} != 0 ]] && validation+='SHA1 Sum'
			[[ ${#sha384sums[@]} != 0 ]] && validation+='SHA384 Sum'
			[[ ${#sha512sums[@]} != 0 ]] && validation+='SHA512 Sum'

			cat <<-INFO
			Repository     : blackarch
			Name           : ${pack}
			Version        : ${pkgver:-0.0.0}-${pkgrel:-1}
			Description    : ${pkgdesc:-None}
			Architecture   : ${arch[@]:-None}
			URL            : ${url:-None}
			Licenses       : ${license[@]:-None}
			Groups         : ${groups[@]:-None}
			Provides       : ${provides[@]:-None}
			Depends On     : ${depends[@]:-None}
			Optional Deps  : ${optdepends[@]:-None}
			Conflicts With : ${conflicts[@]:-None}
			Replaces       : ${replaces[@]:-None}
			Download Size  : ${size:-Unknown}
			Validated By   : ${validation:-None}
			INFO
		) ; done
		;;
	list)
		for pack in packages/* ; do (
			source "$pack/PKGBUILD"
			printf 'blackarch %s %s-%s\n' "$pkgname" "$pkgver" "$pkgrel"
		) ; done
		;;
	upgrade)
		for pack in packages/* ; do (
			source "$pack/PKGBUILD"
			if is_installed $pkgname ; then
				do_sync "$pkgname"
			fi
		) done
		;;
	*)
		error 'action error'
		exit 3
		;;
esac
# Too many subshells.
# vim: set ft=zsh:
